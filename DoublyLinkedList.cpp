#include <iostream> // Подключаем библиотеку iostream для работы с вводом/выводом (например, cout для вывода на экран)

using namespace std; // Используем пространство имен std, чтобы не писать std:: перед cout, cin и другими элементами стандартной библиотеки

// Структура Node представляет узел двусвязного списка
struct Node {
    int data;       // Данные, хранимые в узле (целое число в данном случае). Можно изменить тип данных, если нужно хранить что-то другое
    Node* next;     // Указатель на следующий узел в списке. Если узел последний, то next будет nullptr
    Node* prev;     // Указатель на предыдущий узел в списке. Если узел первый, то prev будет nullptr

    // Конструктор узла: инициализирует данные и указатели next и prev
    // Конструктор вызывается при создании нового узла, например, Node* newNode = new Node(10);
    Node(int value) : data(value), next(nullptr), prev(nullptr) {
        // data(value):  Инициализирует член data значением value, переданным в конструктор
        // next(nullptr): Инициализирует член next значением nullptr (узел пока не указывает ни на какой другой узел)
        // prev(nullptr): Инициализирует член prev значением nullptr (узел пока не указывает ни на какой другой узел)
    }
};

/*
В структуре Node:

*   `data`:  Здесь хранится полезная информация, которую мы хотим хранить в списке.  В данном случае, это целое число (`int`), но можно использовать любой другой тип данных (например, `float`, `string`, или даже другую структуру или класс).
*   `next`:  Это *указатель*.  Он "указывает" на следующий узел в списке.  Указатель хранит адрес памяти, где находится следующий узел.  Если это последний узел в списке, `next` будет равен `nullptr` (что означает "ничего" или "пустой указатель").
*   `prev`: Это *указатель*.  Он "указывает" на предыдущий узел в списке.  Аналогично `next`, он хранит адрес памяти предыдущего узла.  Если это первый узел в списке, `prev` будет равен `nullptr`.
*   `Node(int value) : data(value), next(nullptr), prev(nullptr) {}`: Это конструктор. Конструктор - это специальный метод, который автоматически вызывается, когда мы создаем новый объект (в данном случае, новый узел типа `Node`). Он принимает значение (`value`) для данных узла и устанавливает `next` и `prev` в `nullptr`, так как при создании новый узел еще не связан с другими узлами.
*/

// Класс DoublyLinkedList представляет двусвязный список
class DoublyLinkedList {
private:
    Node* head;     // Указатель на первый узел списка (голова). Если список пуст, head == nullptr
    Node* tail;     // Указатель на последний узел списка (хвост). Если список пуст, tail == nullptr
    int size;       // Количество элементов в списке.  Позволяет быстро узнавать размер списка, не перебирая все элементы

public:
    // Конструктор списка: создает пустой список
    DoublyLinkedList() : head(nullptr), tail(nullptr), size(0) {
        // head(nullptr):  Инициализирует указатель head значением nullptr (список пуст)
        // tail(nullptr):  Инициализирует указатель tail значением nullptr (список пуст)
        // size(0):      Инициализирует размер списка size в 0 (список пуст)
    }

    // Деструктор списка: освобождает память, занятую узлами списка
    // Деструктор вызывается автоматически, когда объект DoublyLinkedList удаляется (например, когда он выходит из области видимости)
    ~DoublyLinkedList() {
        Node* current = head;   // Начинаем с головы списка
        while (current != nullptr) {  // Пока не достигнут конец списка
            Node* next = current->next;  // Сохраняем указатель на следующий узел, чтобы не потерять связь (важно, т.к. current будет удален)
            delete current;              // Удаляем текущий узел.  Освобождаем память, которую он занимал
            current = next;              // Переходим к следующему узлу
        }
        head = nullptr;  // После удаления всех узлов, обнуляем указатель на голову (для безопасности)
        tail = nullptr;  // Обнуляем указатель на хвост (для безопасности)
        size = 0;        // Обнуляем размер списка (для безопасности)
    }

    // Проверка, является ли список пустым
    bool isEmpty() const {
        return head == nullptr;  // Возвращаем true, если head равен nullptr (список пуст), иначе false
        // const означает, что этот метод не изменяет состояние объекта DoublyLinkedList
    }

    // Получение размера списка
    int getSize() const {
        return size; // Возвращаем текущий размер списка
        // const означает, что этот метод не изменяет состояние объекта DoublyLinkedList
    }

    // Добавление элемента в начало списка (push front)
    void push_front(int value) {
        // 1. Создаем новый узел
        Node* newNode = new Node(value);

        // 2. Если список пуст:
        if (isEmpty()) {
            // Новый узел является и головой, и хвостом списка
            head = newNode;  // head указывает на новый узел
            tail = newNode;  // tail указывает на новый узел
        }
        else {
            // 3. Иначе (список не пуст):
            // Устанавливаем указатель next нового узла на текущую голову
            newNode->next = head;  // новый узел "смотрит" на старую голову
            // Устанавливаем указатель prev текущей головы на новый узел
            head->prev = newNode;  // старая голова "смотрит" на новый узел
            // Обновляем указатель head, чтобы он указывал на новый узел
            head = newNode;  // теперь head указывает на новый узел (новый первый элемент)
        }
        // 4. Увеличиваем размер списка
        size++; // увеличиваем счетчик элементов в списке
    }

    // Добавление элемента в конец списка (push back)
    void push_back(int value) {
        // 1. Создаем новый узел
        Node* newNode = new Node(value);

        // 2. Если список пуст:
        if (isEmpty()) {
            // Новый узел является и головой, и хвостом списка
            head = newNode;  // head указывает на новый узел
            tail = newNode;  // tail указывает на новый узел
        }
        else {
            // 3. Иначе (список не пуст):
            // Устанавливаем указатель prev нового узла на текущий хвост
            newNode->prev = tail; // новый узел "смотрит" на старый хвост
            // Устанавливаем указатель next текущего хвоста на новый узел
            tail->next = newNode; // старый хвост "смотрит" на новый узел
            // Обновляем указатель tail, чтобы он указывал на новый узел
            tail = newNode;  // теперь tail указывает на новый узел (новый последний элемент)
        }
        // 4. Увеличиваем размер списка
        size++; // увеличиваем счетчик элементов в списке
    }

    // Удаление элемента из начала списка (pop front)
    void pop_front() {
        // 1. Проверяем, не пуст ли список
        if (isEmpty()) {
            cout << "Ошибка: Невозможно удалить элемент из пустого списка (pop_front)." << endl;
            return; // Если список пуст, ничего не делаем и выводим сообщение об ошибке
        }

        // 2. Сохраняем указатель на текущую голову списка (узел, который нужно удалить)
        Node* temp = head;

        // 3. Обновляем указатель head, чтобы он указывал на следующий узел (второй узел становится первым)
        head = head->next;

        // 4. Если новая голова не nullptr (т.е. в списке остались элементы):
        if (head != nullptr) {
            // Устанавливаем указатель prev новой головы в nullptr (т.к. теперь это первый элемент)
            head->prev = nullptr;
        }
        else {
            // 5. Иначе (список стал пустым):
            // Обнуляем указатель tail
            tail = nullptr; // Если список стал пустым, то и tail должен указывать в nullptr
        }

        // 6. Удаляем узел, на который указывал temp (прежнюю голову списка)
        delete temp; // Освобождаем память

        // 7. Уменьшаем размер списка
        size--; // уменьшаем счетчик элементов в списке
    }

    // Удаление элемента из конца списка (pop back)
    void pop_back() {
        // 1. Проверяем, не пуст ли список
        if (isEmpty()) {
            cout << "Ошибка: Невозможно удалить элемент из пустого списка (pop_back)." << endl;
            return; // Если список пуст, ничего не делаем и выводим сообщение об ошибке
        }

        // 2. Сохраняем указатель на текущий хвост списка (узел, который нужно удалить)
        Node* temp = tail;

        // 3. Обновляем указатель tail, чтобы он указывал на предыдущий узел (предпоследний узел становится последним)
        tail = tail->prev;

        // 4. Если новый хвост не nullptr (т.е. в списке остались элементы):
        if (tail != nullptr) {
            // Устанавливаем указатель next нового хвоста в nullptr (т.к. теперь это последний элемент)
            tail->next = nullptr;
        }
        else {
            // 5. Иначе (список стал пустым):
            // Обнуляем указатель head
            head = nullptr; // Если список стал пустым, то и head должен указывать в nullptr
        }

        // 6. Удаляем узел, на который указывал temp (прежний хвост списка)
        delete temp; // Освобождаем память

        // 7. Уменьшаем размер списка
        size--; // уменьшаем счетчик элементов в списке
    }

    // Вывод элементов списка
    void printList() const {
        Node* current = head;  // Начинаем с головы списка
        while (current != nullptr) { // Пока не достигнут конец списка
            cout << current->data << " ";  // Выводим данные текущего узла (значение data)
            current = current->next; // Переходим к следующему узлу
        }
        cout << endl;  // Переходим на новую строку после вывода всех элементов
        // const означает, что этот метод не изменяет состояние объекта DoublyLinkedList
    }

    // Удаление элемента по значению
    void remove(int value) {
        // 1. Начинаем поиск с головы списка
        Node* current = head;
        // 2. Перебираем список, пока не найдем искомый элемент или не достигнем конца списка
        while (current != nullptr) {
            // 3. Если нашли элемент с заданным значением:
            if (current->data == value) {
                // 4. Перенаправляем указатели соседних узлов, чтобы исключить текущий узел из списка

                // 4.1. Если текущий узел не является головой списка:
                if (current->prev != nullptr) {
                    // Устанавливаем указатель next предыдущего узла на узел, следующий за текущим
                    current->prev->next = current->next;
                }
                else {
                    // 4.2. Если текущий узел является головой списка:
                    // Обновляем указатель на голову списка, чтобы он указывал на следующий узел
                    head = current->next;
                }

                // 5. Обновляем указатель prev следующего узла (если он существует)
                if (current->next != nullptr) {
                    current->next->prev = current->prev;
                }
                else {
                    // 6. Если текущий узел является хвостом списка:
                    // Обновляем указатель на хвост списка, чтобы он указывал на предыдущий узел
                    tail = current->prev;
                }

                // 7. Освобождаем память, занимаемую удаляемым узлом
                Node* temp = current;
                current = current->next;
                delete temp;

                // 8. Уменьшаем размер списка
                size--;

                // 9. Завершаем работу функции
                return;
            }
            // 10. Переходим к следующему узлу в списке
            current = current->next;
        }
        // 11. Если элемент с заданным значением не найден, выводим сообщение об ошибке
        cout << "Элемент со значением " << value << " не найден." << endl;
    }

    // Переворот списка
    void reverse() {
        // 1. Начинаем с головы списка
        Node* current = head;
        Node* temp = nullptr;

        // 2. Перебираем список, пока не достигнем конца
        while (current != nullptr) {
            // 3. Меняем местами указатели next и prev текущего узла
            temp = current->prev; // Сохраняем указатель на предыдущий узел во временной переменной
            current->prev = current->next; // Указатель prev текущего узла теперь указывает на следующий узел
            current->next = temp; // Указатель next текущего узла теперь указывает на предыдущий узел (из временной переменной)

            // 4. Переходим к следующему узлу (теперь это узел, на который раньше указывал prev)
            current = current->prev;
        }

        // 5. После переворота head указывает на последний элемент, а tail на первый
        // Обновляем head, чтобы он указывал на новый первый элемент
        if (temp != nullptr) {
            head = temp->prev; // Устанавливаем head на новый первый элемент
        }
    }

    // Поиск элемента по значению
    bool find(int value) const {
        // 1. Начинаем поиск с головы списка
        Node* current = head;
        // 2. Перебираем список, пока не найдем искомый элемент или не достигнем конца списка
        while (current != nullptr) {
            // 3. Если нашли элемент с заданным значением:
            if (current->data == value) {
                // 4. Возвращаем true, сигнализируя об успехе
                return true;
            }
            // 5. Переходим к следующему узлу в списке
            current = current->next;
        }
        // 6. Если элемент с заданным значением не найден, возвращаем false
        return false;
    }
};

int main() {
    DoublyLinkedList myList; // Создаем объект двусвязного списка с именем myList

    myList.push_front(1); // Добавляем элемент 1 в начало списка
    myList.push_back(3);  // Добавляем элемент 3 в конец списка
    myList.push_front(0); // Добавляем элемент 0 в начало списка
    myList.push_back(5);  // Добавляем элемент 5 в конец списка

    cout << "Список: "; // Выводим на экран "Список: "
    myList.printList(); // Выводим элементы списка: 0 1 3 5

    cout << "Размер списка: " << myList.getSize() << endl; // Выводим размер списка: 4
    cout << "Список пуст? " << (myList.isEmpty() ? "Да" : "Нет") << endl; // Выводим, пуст ли список: Нет

    cout << "Найдено ли значение 3? " << (myList.find(3) ? "Да" : "Нет") << endl; // Проверяем, есть ли элемент 3 в списке: Да
    cout << "Найдено ли значение 4? " << (myList.find(4) ? "Да" : "Нет") << endl; // Проверяем, есть ли элемент 4 в списке: Нет

    myList.remove(1); // Удаляем элемент 1 из списка
    cout << "Список после удаления 1: "; // Выводим на экран "Список после удаления 1: "
    myList.printList(); // Выводим элементы списка: 0 3 5

    myList.reverse(); // Переворачиваем список
    cout << "Список после переворота: "; // Выводим на экран "Список после переворота: "
    myList.printList(); // Выводим элементы списка: 5 3 0

    myList.pop_front(); // Удаляем первый элемент из списка
    cout << "Список после pop_front: "; // Выводим на экран "Список после pop_front: "
    myList.printList(); // Выводим элементы списка: 3 0

    myList.pop_back();  // Удаляем последний элемент из списка
    cout << "Список после pop_back: ";  // Выводим на экран "Список после pop_back: "
    myList.printList(); // Выводим элементы списка: 3

    return 0; // Возвращаем 0, сигнализируя об успешном завершении программы
}
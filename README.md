Реализация Linked list на C++

Что такое связный список?
Связный список — базовая динамическая структура данных, состоящая из узлов, содержащих данные и ссылки («связки») на следующий и/или предыдущий узел списка. Принципиальным преимуществом перед массивом является структурная гибкость: порядок элементов связного списка может не совпадать с порядком расположения элементов данных в памяти компьютера, а порядок обхода списка всегда явно задаётся его внутренними связями.



Области применения связных списков:
1. Реализация других структур данных:

Пример: Стеки и очереди можно реализовать с использованием связных списков.

Объяснение: Связные списки обеспечивают удобный способ добавления и удаления элементов в начале (стек) или в начале и конце (очередь).

2. Управление памятью:

Пример: В операционных системах списки свободной памяти часто реализуются с использованием связных списков.

Объяснение: Операционная система хранит список доступных блоков памяти, и связный список позволяет эффективно добавлять и удалять блоки из этого списка.

3. Списки воспроизведения (плейлисты):

Пример: Реализация плейлиста в музыкальном проигрывателе.

Объяснение: Можно легко добавлять, удалять и переставлять треки в плейлисте, используя связный список.

4. Реализация Undo/Redo функциональности:

Пример: В текстовых редакторах или графических редакторах, где нужно отменять и повторять действия.

Объяснение: Каждое действие пользователя можно представить как узел в связном списке. Операция Undo перемещает указатель к предыдущему действию, а Redo – к следующему.

5. Хранение данных переменной длины:

Пример: Хранение больших чисел, размер которых может меняться во время выполнения программы.

Объяснение: Каждая цифра числа может храниться в отдельном узле связного списка.

6. Графы:

Пример: Представление списков смежности в графах.

Объяснение: Для каждой вершины графа можно хранить список смежных вершин, используя связный список.



1. Односвязный список (Single linked list) 
Это фундаментальная структура данных, представляющая собой линейную последовательность элементов, называемых узлами (nodes). Каждый узел содержит:

Данные (Data): Информация, которую необходимо хранить. Это может быть любой тип данных: целое число, символ, строка, структура, объект и т.д.
Указатель на следующий узел (Next): Адрес следующего узла в последовательности. Этот указатель связывает узлы вместе, формируя список.
Важно отметить, что последний узел в односвязном списке имеет свой указатель Next, установленный в nullptr. Это сигнализирует о конце списка.

Структура односвязного списка:

Узлы (Nodes): Базовые строительные блоки списка. Каждый узел хранит данные и ссылку на следующий узел.
Головной узел (Head): Указатель, который хранит адрес первого узла в списке. Он является точкой входа в список. Если список пуст, Head равен nullptr. Head - это ключевой элемент, без которого невозможно получить доступ к списку.
Хвостовой узел (Tail): Последний узел в списке. Он характеризуется тем, что его указатель Next равен nullptr. Хвостовой узел часто, но не всегда, хранится как отдельная переменная в структуре данных списка. Если он не хранится отдельно, его можно найти, пройдясь по всему списку, начиная с Head, пока не будет найден узел, у которого Next == nullptr.

Single linked list
Head: Указатель на первый узел.

[Data, Next]: Представляет один узел, состоящий из данных и указателя на следующий узел.

-->: Обозначает направление указателя Next. Показывает, что указатель Next хранит адрес следующего узла.

nullptr: Обозначает конец списка. Указывает на то, что узел является последним.

Основные методы 
1. Конструктор (LinkedList())

Что выполняет: Создает экземпляр пустого односвязного списка.

Объяснение: 

a. Инициализирует указатель head значением nullptr, что указывает на отсутствие первого элемента (список пуст).

b. Инициализирует указатель tail значением nullptr (если используется), что также указывает на отсутствие последнего элемента.

c. Инициализирует переменную size (если используется) значением 0.



2. Деструктор (~LinkedList())

Что выполняет: Освобождает всю память, выделенную для узлов списка, чтобы избежать утечек памяти.

Объяснение: 

a. Обходит список, начиная с head.

b. Для каждого узла сохраняет указатель на следующий узел, удаляет текущий узел и переходит к следующему.



3.  Добавление в начало (push_front(data))

Что выполняет: Добавляет новый узел с данными data в начало списка.

Объяснение: 

a. Создает новый узел (newNode) с заданными данными.

b. Устанавливает newNode->next на текущий head, чтобы новый узел указывал на предыдущий первый узел.

c. Обновляет head на newNode, чтобы новый узел стал первым в списке.

d. Если список был пуст, устанавливает tail на newNode (если используется).

e. Увеличивает размер списка size (если используется).



4. Добавление в конец (push_back(data))

Что выполняет: Добавляет новый узел с данными data в конец списка.

Объяснение:

a. Создает новый узел (newNode) с заданными данными.

b. Если список пуст, устанавливает head и tail (если используется) на newNode.

c. Иначе, устанавливает tail->next на newNode и обновляет tail на newNode.

d. Увеличивает размер списка size (если используется).



5. Удаление из начала (pop_front())

Что выполняет: Удаляет первый узел из списка.

Объяснение:

a. Проверяет, не пуст ли список. Если пуст, ничего не делает.

b. Сохраняет указатель на текущий head во временной переменной (temp).

c. Обновляет head на head->next, чтобы второй узел стал первым.

d. Если список стал пуст, устанавливает tail на nullptr (если используется).

e. Освобождает память, на которую указывает temp (удаляет первый узел).

f. Уменьшает размер списка size (если используется).



6. Удаление из конца (pop_back())

Что выполняет: Удаляет последний узел из списка. Реализация без хранения tail будет неэффективной (O(n)).

Объяснение (с хранением tail):

a. Проверяет, не пуст ли список, и если пуст - заканчивает выполнение.

b. Если в списке только один элемент, то head и tail устанавливаются в nullptr.

c. Иначе, необходимо найти предпоследний узел списка. Это можно сделать, пройдясь по списку от head до тех пор, пока current->next != tail.

d. tail перемещается на предпоследний элемент.

e. next предпоследнего элемента (нового tail) устанавливается на nullptr.

f. Старый tail удаляется.

j. Размер списка уменьшается.



7. Получение размера (getSize())

Что выполняет: Возвращает количество элементов в списке.

Объяснение:

a. Возвращает значение переменной size, которая отслеживает количество узлов в списке.



8. Проверка на пустоту (isEmpty())

Что выполняет: Возвращает true, если список пуст, и false в противном случае.

Объяснение:

a. Проверяет, равен ли указатель head значению nullptr.



9. Вывод списка (printList())

Что выполняет: Выводит значения всех элементов в списке на экран. (Это, скорее, вспомогательный метод для отладки, чем строго необходимый).

Объяснение:

a. Начинает с head.

b. Перебирает список, пока не достигнет конца (nullptr).

c. Для каждого узла выводит значение data.



Эти методы представляют собой ядро реализации односвязного списка. Понимание принципов их работы необходимо для эффективного использования и расширения этой структуры данных. Вариации реализации, такие как хранение указателя на tail, могут существенно влиять на производительность некоторых операций.



2. Двусвязный список (Double linked list) 
Это линейная структура данных, представляющая собой последовательность элементов, называемых узлами (nodes). Каждый узел содержит:

Данные (Data): Информация, которую необходимо хранить в этом узле. Это может быть любой тип данных: число, символ, строка, объект и т.д.
Указатель на следующий узел (Next): Адрес следующего узла в последовательности. Этот указатель позволяет перемещаться по списку в прямом направлении.
Указатель на предыдущий узел (Prev): Адрес предыдущего узла в последовательности. Этот указатель позволяет перемещаться по списку в обратном направлении.
В двусвязном списке первый узел имеет Prev указатель, установленный в nullptr, а последний узел имеет Next указатель, установленный в nullptr.



Структура (как организован):

Узлы (Nodes): Базовые строительные блоки списка. Каждый узел хранит данные и два указателя: на следующий и на предыдущий узлы.
Головной узел (Head): Указатель, который хранит адрес первого узла в списке. Он является точкой входа в список. Если список пуст, Head равен nullptr.
Хвостовой узел (Tail): Указатель, который хранит адрес последнего узла в списке. Если список пуст, Tail равен nullptr. Хранение Tail позволяет эффективно добавлять и удалять элементы в конце списка.



Double linked list
Head: Указатель на первый узел (Head->Prev == nullptr).

Tail: Указатель на последний узел (Tail->Next == nullptr).

[Prev, Data, Next]: Представляет один узел, состоящий из указателя на предыдущий узел, данных и указателя на следующий узел.

<-->: Обозначает двунаправленные связи между узлами, создаваемые указателями Prev и Next.

Как происходит обмен адресами между узлами?
Обмен адресами между узлами в связном списке происходит посредством манипулирования указателями Next (в односвязном списке) и Next и Prev (в двусвязном списке). Давайте разберем этот процесс подробнее:

1. Указатели как “связующее звено”:

Указатели Next и Prev внутри каждого узла играют роль “связующего звена”, храня адреса других узлов. Когда создается новый узел или изменяется структура списка, эти указатели обновляются, чтобы правильно отражать связи между узлами.



2. Создание нового узла и его интеграция в список:

Предположим, у нас есть односвязный список и мы хотим добавить новый узел (newNode) после существующего узла (existingNode).

Шаг 1: Выделение памяти. Создается новый узел и в его поле data вносятся данные.

Шаг 2: Установка newNode->Next. Указатель Next нового узла устанавливается равным existingNode->Next. Это означает, что newNode теперь “смотрит” на тот же узел, на который смотрел existingNode.

Шаг 3: Изменение existingNode->Next. Указатель Next существующего узла устанавливается равным newNode. Теперь existingNode “смотрит” на newNode.

В результате, newNode оказывается “вставленным” между existingNode и узлом, на который раньше указывал existingNode.



3. Аналогичный процесс для двусвязного списка:

В двусвязном списке процесс аналогичен, но нужно обновлять два указателя (Next и Prev):

При добавлении нового узла (newNode) после существующего (existingNode):newNode->Next = existingNode->Next;

newNode->Prev = existingNode;

existingNode->Next->Prev = newNode; (если existingNode не последний узел)

existingNode->Next = newNode;



4. Обновление Head и Tail:

Если новый узел добавляется в начало списка, необходимо обновить указатель head, чтобы он указывал на новый первый узел.

Если новый узел добавляется в конец списка (или удаляется последний элемент), необходимо обновить указатель tail.



5. Ключевые моменты:

Адреса хранятся в указателях: Передача адресов происходит путем присваивания значений указателям.

Последовательное обновление: Важно обновлять указатели в правильном порядке, чтобы не потерять связь с остальной частью списка. Неправильный порядок может привести к “разрыву” списка и утечкам памяти.

Динамическая природа: Обмен адресами между узлами позволяет динамически изменять структуру списка, добавляя, удаляя и переставляя элементы.



Основные операции:
 1. Конструктор (DoublyLinkedList())

Что выполняет: Создает пустой двусвязный список.

Реализация:

Инициализирует указатели head и tail значением nullptr (список пуст).
Инициализирует размер списка size в 0 (если используется).


2. Деструктор (~DoublyLinkedList())

Что выполняет: Освобождает всю память, выделенную для узлов списка, чтобы предотвратить утечки памяти.

Реализация:

Обходит список, начиная с head.
Для каждого узла сохраняет указатель на следующий узел, удаляет текущий узел и переходит к следующему.


3. Добавление в начало (push_front(data))

Что выполняет: Добавляет новый узел с данными data в начало списка.

Реализация:

Создает новый узел (newNode) с заданными данными.
Устанавливает newNode->next на текущий head (новый узел указывает на старый head).
Устанавливает newNode->prev в nullptr (новый узел теперь первый).
Если список не пуст (head != nullptr), то устанавливает head->prev на newNode (предыдущий узел для старого head - новый узел).
Обновляет head на newNode (новый узел теперь head).
Если список был пуст, то устанавливает tail на newNode.
Увеличивает размер списка size (если используется).


4. Добавление в конец (push_back(data))

Что выполняет: Добавляет новый узел с данными data в конец списка.

Реализация:

Создает новый узел (newNode) с заданными данными.
Устанавливает newNode->next в nullptr (новый узел теперь последний).
Устанавливает newNode->prev на текущий tail (предыдущий узел для нового узла - это текущий tail).
Если список не пуст (tail != nullptr), устанавливает tail->next на newNode (следующий узел для старого tail - новый узел).
Обновляет tail на newNode (новый узел теперь tail).
Если список был пуст, устанавливает head на newNode.
Увеличивает размер списка size (если используется).


5. Удаление из начала (pop_front())

Что выполняет: Удаляет первый узел из списка.

Реализация:

Если список пуст, ничего не делает.
Сохраняет указатель на текущий head во временной переменной (temp).
Обновляет head на head->next (второй узел становится первым).
Если новый head не nullptr, устанавливает head->prev в nullptr (теперь у нового head нет предыдущего узла).
Если удалялся единственный элемент в списке, то tail также устанавливается в nullptr.
Освобождает память, занимаемую удаленным узлом (temp).
Уменьшает размер списка size (если используется).


6. Удаление из конца (pop_back())

Что выполняет: Удаляет последний узел из списка.

Реализация:

Если список пуст, ничего не делает.
Сохраняет указатель на текущий tail во временной переменной (temp).
Обновляет tail на tail->prev (предпоследний узел становится последним).
Если новый tail не nullptr, устанавливает tail->next в nullptr (теперь у нового tail нет следующего узла).
Если удалялся единственный элемент в списке, то head также устанавливается в nullptr.
Освобождает память, занимаемую удаленным узлом (temp).
Уменьшает размер списка size (если используется).


7. Получение первого элемента (getFront())

Что выполняет: Возвращает значение первого элемента в списке.

Реализация:

 Возвращает head->data. Необходимо проверить, что список не пуст.


8. Получение последнего элемента (getBack())

Что выполняет: Возвращает значение последнего элемента в списке.

Реализация: 

Возвращает tail->data. Необходимо проверить, что список не пуст.


9. Проверка на пустоту (isEmpty())

Что выполняет: Возвращает true, если список пуст, и false в противном случае.

Реализация:

 Проверяет, равен ли head nullptr.


10. Получение размера (getSize())

Что выполняет: Возвращает количество элементов в списке.

Реализация: 

Возвращает значение переменной size, которая хранит размер списка.


11. Поиск элемента (find(data))

Что выполняет: Ищет первый узел со значением data и возвращает указатель на него (или nullptr, если не найдено).

Реализация: 

Перебирает список, начиная с head (или с tail, если вы хотите искать в обратном направлении) и сравнивает data каждого узла с искомым значением.


12. Вставка после (insertAfter(node, data))

Что выполняет: Вставляет новый узел со значением data после заданного узла node.

Реализация:

Создает новый узел (newNode) с данными data.
Устанавливает newNode->next на node->next (новый узел указывает на следующий узел после заданного).
Устанавливает newNode->prev на node (новый узел указывает на заданный узел).
Если node->next не nullptr (заданный узел не последний), устанавливает node->next->prev на newNode (предыдущий узел для следующего после заданного узла - новый узел).
Устанавливает node->next на newNode (следующий узел для заданного узла - новый узел).
Если node был tail, обновляет tail.
Увеличивает размер списка size (если используется).


13. Вставка перед (insertBefore(node, data))

Что выполняет: Вставляет новый узел со значением data перед заданным узлом node.

Реализация:

Создает новый узел (newNode) с данными data.
Устанавливает newNode->prev на node->prev (новый узел указывает на предыдущий узел от заданного).
Устанавливает newNode->next на node (новый узел указывает на заданный узел).
Если node->prev не nullptr (заданный узел не первый), устанавливает node->prev->next на newNode (следующий узел для предыдущего от заданного узла - новый узел).
Устанавливает node->prev на newNode (предыдущий узел для заданного узла - новый узел).
Если node был head, обновляет head.
Увеличивает размер списка size (если используется).


14. Удаление заданного узла (remove(node))

Что выполняет: Удаляет указанный узел node из списка.

Реализация:

Если node - это head, вызывает pop_front().
Если node - это tail, вызывает pop_back().
Иначе:Устанавливает node->prev->next на node->next (предыдущий узел для node теперь указывает на следующий узел после node).
Устанавливает node->next->prev на node->prev (следующий узел для node теперь указывает на предыдущий узел перед node).
Освобождает память, занимаемую удаленным узлом (node).
Уменьшает размер списка size (если используется).


15. Вывод списка (printList()) (вспомогательный метод для отладки)

Что выполняет: Выводит значения всех элементов в списке на экран (в прямом или обратном порядке).

Реализация:

 Перебирает список и выводит data каждого узла.


Преимущества связных списков:
1. Динамический размер:

Преимущество: Размер списка может изменяться во время выполнения программы. Нет необходимости заранее определять максимальный размер.

Пример: Если вы создаете список задач, количество задач может меняться динамически.

2. Эффективные вставки и удаления:

Преимущество: Вставка и удаление элементов в середине списка выполняются за O(1) время, если у вас уже есть указатель на нужный узел.

Пример: В текстовом редакторе вставка и удаление символов в любом месте текста.

3. Гибкое управление памятью:

Преимущество: Узлы списка могут быть расположены в разных участках памяти. Не требуется непрерывный блок.

Пример: Когда не хватает непрерывной памяти для массива, связный список позволяет разместить элементы в разрозненных блоках.



Недостатки связных списков:
1. Медленный доступ к произвольному элементу:

Недостаток: Для доступа к элементу по индексу необходимо последовательно перебирать элементы, начиная с начала списка (O(n) время).

Пример: Если вам нужно часто получать доступ к элементам по индексу (например, list[5]), то массив будет более эффективным.

2. Дополнительные затраты памяти:

Недостаток: Для каждого элемента (узла) необходимо хранить указатель(и) (на следующий и, возможно, предыдущий элемент). Это увеличивает потребление памяти.

Пример: Если храните небольшие целые числа, то накладные расходы на указатели могут быть существенными.

3. Кэш-недружественность:

Недостаток: Узлы списка могут быть разбросаны по памяти, что снижает эффективность использования кэша процессора (по сравнению с массивами, где элементы расположены последовательно).

Пример: При интенсивном переборе элементов списка может наблюдаться снижение производительности из-за частых промахов кэша.



Вывод
Использовать связный список стоит в тех случаях, когда:

Требуется частое добавление и удаление элементов, особенно в середине списка.
Размер данных заранее неизвестен и может изменяться динамически.
Не критична скорость доступа к произвольным элементам по индексу.
Гибкое управление памятью важнее, чем экономия памяти.

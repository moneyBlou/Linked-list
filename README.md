Что такое связный список?
Связный список — базовая динамическая структура данных, состоящая из узлов, содержащих данные и ссылки («связки») на следующий и/или предыдущий узел списка. Принципиальным преимуществом перед массивом является структурная гибкость: порядок элементов связного списка может не совпадать с порядком расположения элементов данных в памяти компьютера, а порядок обхода списка всегда явно задаётся его внутренними связями.

Области применения связных списков:
1. Реализация других структур данных:

Пример: Стеки и очереди можно реализовать с использованием связных списков.

Объяснение: Связные списки обеспечивают удобный способ добавления и удаления элементов в начале (стек) или в начале и конце (очередь).

2. Управление памятью:

Пример: В операционных системах списки свободной памяти часто реализуются с использованием связных списков.

Объяснение: Операционная система хранит список доступных блоков памяти, и связный список позволяет эффективно добавлять и удалять блоки из этого списка.

3. Списки воспроизведения (плейлисты):

Пример: Реализация плейлиста в музыкальном проигрывателе.

Объяснение: Можно легко добавлять, удалять и переставлять треки в плейлисте, используя связный список.

4. Реализация Undo/Redo функциональности:

Пример: В текстовых редакторах или графических редакторах, где нужно отменять и повторять действия.

Объяснение: Каждое действие пользователя можно представить как узел в связном списке. Операция Undo перемещает указатель к предыдущему действию, а Redo – к следующему.

5. Хранение данных переменной длины:

Пример: Хранение больших чисел, размер которых может меняться во время выполнения программы.

Объяснение: Каждая цифра числа может храниться в отдельном узле связного списка.

6. Графы:

Пример: Представление списков смежности в графах.

Объяснение: Для каждой вершины графа можно хранить список смежных вершин, используя связный список.



1. Односвязный список (Single linked list) 
Реализация кода можно посмотреть на GitHub
Это фундаментальная структура данных, представляющая собой линейную последовательность элементов, называемых узлами (nodes). Каждый узел содержит:

Данные (Data): Информация, которую необходимо хранить. Это может быть любой тип данных: целое число, символ, строка, структура, объект и т.д.
Указатель на следующий узел (Next): Адрес следующего узла в последовательности. Этот указатель связывает узлы вместе, формируя список.
Важно отметить, что последний узел в односвязном списке имеет свой указатель Next, установленный в nullptr. Это сигнализирует о конце списка.

Структура односвязного списка:

Узлы (Nodes): Базовые строительные блоки списка. Каждый узел хранит данные и ссылку на следующий узел.
Головной узел (Head): Указатель, который хранит адрес первого узла в списке. Он является точкой входа в список. Если список пуст, Head равен nullptr. Head - это ключевой элемент, без которого невозможно получить доступ к списку.
Хвостовой узел (Tail): Последний узел в списке. Он характеризуется тем, что его указатель Next равен nullptr. Хвостовой узел часто, но не всегда, хранится как отдельная переменная в структуре данных списка. Если он не хранится отдельно, его можно найти, пройдясь по всему списку, начиная с Head, пока не будет найден узел, у которого Next == nullptr.

Single linked list
Head: Указатель на первый узел.

[Data, Next]: Представляет один узел, состоящий из данных и указателя на следующий узел.

-->: Обозначает направление указателя Next. Показывает, что указатель Next хранит адрес следующего узла.

nullptr: Обозначает конец списка. Указывает на то, что узел является последним.

Основные методы 
1. Конструктор (LinkedList())

Что выполняет: Создает экземпляр пустого односвязного списка.

Объяснение: 

a. Инициализирует указатель head значением nullptr, что указывает на отсутствие первого элемента (список пуст).

b. Инициализирует указатель tail значением nullptr (если используется), что также указывает на отсутствие последнего элемента.

c. Инициализирует переменную size (если используется) значением 0.



2. Деструктор (~LinkedList())

Что выполняет: Освобождает всю память, выделенную для узлов списка, чтобы избежать утечек памяти.

Объяснение: 

a. Обходит список, начиная с head.

b. Для каждого узла сохраняет указатель на следующий узел, удаляет текущий узел и переходит к следующему.



3.  Добавление в начало (push_front(data))

Что выполняет: Добавляет новый узел с данными data в начало списка.

Объяснение: 

a. Создает новый узел (newNode) с заданными данными.

b. Устанавливает newNode->next на текущий head, чтобы новый узел указывал на предыдущий первый узел.

c. Обновляет head на newNode, чтобы новый узел стал первым в списке.

d. Если список был пуст, устанавливает tail на newNode (если используется).

e. Увеличивает размер списка size (если используется).



4. Добавление в конец (push_back(data))

Что выполняет: Добавляет новый узел с данными data в конец списка.

Объяснение:

a. Создает новый узел (newNode) с заданными данными.

b. Если список пуст, устанавливает head и tail (если используется) на newNode.

c. Иначе, устанавливает tail->next на newNode и обновляет tail на newNode.

d. Увеличивает размер списка size (если используется).



5. Удаление из начала (pop_front())

Что выполняет: Удаляет первый узел из списка.

Объяснение:

a. Проверяет, не пуст ли список. Если пуст, ничего не делает.

b. Сохраняет указатель на текущий head во временной переменной (temp).

c. Обновляет head на head->next, чтобы второй узел стал первым.

d. Если список стал пуст, устанавливает tail на nullptr (если используется).

e. Освобождает память, на которую указывает temp (удаляет первый узел).

f. Уменьшает размер списка size (если используется).



6. Удаление из конца (pop_back())

Что выполняет: Удаляет последний узел из списка. Реализация без хранения tail будет неэффективной (O(n)).

Объяснение (с хранением tail):

a. Проверяет, не пуст ли список, и если пуст - заканчивает выполнение.

b. Если в списке только один элемент, то head и tail устанавливаются в nullptr.

c. Иначе, необходимо найти предпоследний узел списка. Это можно сделать, пройдясь по списку от head до тех пор, пока current->next != tail.

d. tail перемещается на предпоследний элемент.

e. next предпоследнего элемента (нового tail) устанавливается на nullptr.

f. Старый tail удаляется.

j. Размер списка уменьшается.



7. Получение размера (getSize())

Что выполняет: Возвращает количество элементов в списке.

Объяснение:

a. Возвращает значение переменной size, которая отслеживает количество узлов в списке.



8. Проверка на пустоту (isEmpty())

Что выполняет: Возвращает true, если список пуст, и false в противном случае.

Объяснение:

a. Проверяет, равен ли указатель head значению nullptr.



9. Вывод списка (printList())

Что выполняет: Выводит значения всех элементов в списке на экран. (Это, скорее, вспомогательный метод для отладки, чем строго необходимый).

Объяснение:

a. Начинает с head.

b. Перебирает список, пока не достигнет конца (nullptr).

c. Для каждого узла выводит значение data.



Эти методы представляют собой ядро реализации односвязного списка. Понимание принципов их работы необходимо для эффективного использования и расширения этой структуры данных. Вариации реализации, такие как хранение указателя на tail, могут существенно влиять на производительность некоторых операций.



2. Двусвязный список (Double linked list) 
Это линейная структура данных, представляющая собой последовательность элементов, называемых узлами (nodes). Каждый узел содержит:

Данные (Data): Информация, которую необходимо хранить в этом узле. Это может быть любой тип данных: число, символ, строка, объект и т.д.
Указатель на следующий узел (Next): Адрес следующего узла в последовательности. Этот указатель позволяет перемещаться по списку в прямом направлении.
Указатель на предыдущий узел (Prev): Адрес предыдущего узла в последовательности. Этот указатель позволяет перемещаться по списку в обратном направлении.
В двусвязном списке первый узел имеет Prev указатель, установленный в nullptr, а последний узел имеет Next указатель, установленный в nullptr.



Структура (как организован):

Узлы (Nodes): Базовые строительные блоки списка. Каждый узел хранит данные и два указателя: на следующий и на предыдущий узлы.
Головной узел (Head): Указатель, который хранит адрес первого узла в списке. Он является точкой входа в список. Если список пуст, Head равен nullptr.
Хвостовой узел (Tail): Указатель, который хранит адрес последнего узла в списке. Если список пуст, Tail равен nullptr. Хранение Tail позволяет эффективно добавлять и удалять элементы в конце списка.



Doubly linked list
Head: Указатель на первый узел (Head->Prev == nullptr).

Tail: Указатель на последний узел (Tail->Next == nullptr).

[Prev, Data, Next]: Представляет один узел, состоящий из указателя на предыдущий узел, данных и указателя на следующий узел.

<-->: Обозначает двунаправленные связи между узлами, создаваемые указателями Prev и Next.

Как происходит обмен адресами между узлами?
Обмен адресами между узлами в связном списке происходит посредством манипулирования указателями Next (в односвязном списке) и Next и Prev (в двусвязном списке). Давайте разберем этот процесс подробнее:

1. Указатели как “связующее звено”:

Указатели Next и Prev внутри каждого узла играют роль “связующего звена”, храня адреса других узлов. Когда создается новый узел или изменяется структура списка, эти указатели обновляются, чтобы правильно отражать связи между узлами.



2. Создание нового узла и его интеграция в список:

Предположим, у нас есть односвязный список и мы хотим добавить новый узел (newNode) после существующего узла (existingNode).

Шаг 1: Выделение памяти. Создается новый узел и в его поле data вносятся данные.

Шаг 2: Установка newNode->Next. Указатель Next нового узла устанавливается равным existingNode->Next. Это означает, что newNode теперь “смотрит” на тот же узел, на который смотрел existingNode.

Шаг 3: Изменение existingNode->Next. Указатель Next существующего узла устанавливается равным newNode. Теперь existingNode “смотрит” на newNode.

В результате, newNode оказывается “вставленным” между existingNode и узлом, на который раньше указывал existingNode.



3. Аналогичный процесс для двусвязного списка:

В двусвязном списке процесс аналогичен, но нужно обновлять два указателя (Next и Prev):

При добавлении нового узла (newNode) после существующего (existingNode):newNode->Next = existingNode->Next;

newNode->Prev = existingNode;

existingNode->Next->Prev = newNode; (если existingNode не последний узел)

existingNode->Next = newNode;



4. Обновление Head и Tail:

Если новый узел добавляется в начало списка, необходимо обновить указатель head, чтобы он указывал на новый первый узел.

Если новый узел добавляется в конец списка (или удаляется последний элемент), необходимо обновить указатель tail.



5. Ключевые моменты:

Адреса хранятся в указателях: Передача адресов происходит путем присваивания значений указателям.

Последовательное обновление: Важно обновлять указатели в правильном порядке, чтобы не потерять связь с остальной частью списка. Неправильный порядок может привести к “разрыву” списка и утечкам памяти.

Динамическая природа: Обмен адресами между узлами позволяет динамически изменять структуру списка, добавляя, удаляя и переставляя элементы.



1. Необходимые методы для реализации двусвязного списка:
1.1. Конструктор ( DoublyLinkedList() )

Что выполняет: Создает пустой двусвязный список.

Реализация:

Инициализирует указатель head значением nullptr (список пуст).
Инициализирует указатель tail значением nullptr (список пуст).
Инициализирует размер списка size значением 0 (если используется поле size).
1.2. Деструктор ( ~DoublyLinkedList() )

Что выполняет: Освобождает память, занятую узлами списка, предотвращая утечку памяти.

Реализация:

Устанавливает указатель current на начало списка (head).
Пока current не равен nullptr (пока не достигнут конец списка):Сохраняет указатель на следующий узел (next = current->next).
Удаляет текущий узел (delete current).
Перемещает current на следующий узел (current = next).
Устанавливает указатель head в nullptr.
Устанавливает указатель tail в nullptr.
Устанавливает размер списка size в 0 (если используется поле size).
1.3. Проверка на пустоту isEmpty()

Что выполняет: Проверяет, пуст ли список.

Реализация:

Возвращает true, если head равен nullptr.
Возвращает false в противном случае.
1.4. Метод получение размера getSize()

Что выполняет: Возвращает размер списка (количество элементов).

Реализация:

Возвращает значение переменной size.
1.5. Добавление с начало списка push_front(int value)

Что выполняет: Добавляет новый элемент в начало списка.

Реализация:

Создает новый узел newNode с заданным значением value.
Если список пуст (isEmpty() возвращает true):Устанавливает head на newNode.
Устанавливает tail на newNode.
Иначе (список не пуст):Устанавливает newNode->next на head.
Устанавливает head->prev на newNode.
Устанавливает head на newNode.
Увеличивает size на 1.
1.6. Добавление с конца списка push_back(int value)

Что выполняет: Добавляет новый элемент в конец списка.

Реализация:

Создает новый узел newNode с заданным значением value.
Если список пуст (isEmpty() возвращает true):Устанавливает head на newNode.
Устанавливает tail на newNode.
Иначе (список не пуст):Устанавливает newNode->prev на tail.
Устанавливает tail->next на newNode.
Устанавливает tail на newNode.
Увеличивает size на 1.
1.7. Удаление с начала pop_front()

Что выполняет: Удаляет элемент из начала списка.

Реализация:

Если список пуст (isEmpty() возвращает true), выполняет обработку ошибки (например, выводит сообщение об ошибке).
Сохраняет указатель на текущую голову списка в temp (temp = head).
Перемещает head на следующий узел (head = head->next).
Если head не равен nullptr (в списке остались элементы):Устанавливает head->prev в nullptr.
Иначе (список стал пустым):Устанавливает tail в nullptr.
Удаляет узел, на который указывает temp (delete temp).
Уменьшает size на 1.
1.8. Удаление с конца pop_back()

Что выполняет: Удаляет элемент из конца списка.

Реализация:

Если список пуст (isEmpty() возвращает true), выполняет обработку ошибки (например, выводит сообщение об ошибке).
Сохраняет указатель на текущий хвост списка в temp (temp = tail).
Перемещает tail на предыдущий узел (tail = tail->prev).
Если tail не равен nullptr (в списке остались элементы):Устанавливает tail->next в nullptr.
Иначе (список стал пустым):Устанавливает head в nullptr.
Удаляет узел, на который указывает temp (delete temp).
Уменьшает size на 1.


2. Методы, которые можно добавить по желанию (в зависимости от задачи):
printList(): Вывод элементов списка в прямом порядке.
printListReverse(): Вывод элементов списка в обратном порядке.
insertAfter(int afterValue, int newValue): Вставка элемента после заданного значения.
insertBefore(int beforeValue, int newValue): Вставка элемента перед заданным значением.
remove(int value): Удаление элемента по значению.
removeAt(int index): Удаление элемента по индексу.
find(int value): Поиск элемента по значению.
getAt(int index): Получение значения элемента по индексу.
setAt(int index, int newValue): Установка значения элемента по индексу.
clear(): Удаление всех элементов из списка.
reverse(): Переворот списка.
concatenate(DoublyLinkedList& otherList): Объединение с другим списком.


Преимущества связных списков:
1. Динамический размер:

Преимущество: Размер списка может изменяться во время выполнения программы. Нет необходимости заранее определять максимальный размер.

Пример: Если вы создаете список задач, количество задач может меняться динамически.

2. Эффективные вставки и удаления:

Преимущество: Вставка и удаление элементов в середине списка выполняются за O(1) время, если у вас уже есть указатель на нужный узел.

Пример: В текстовом редакторе вставка и удаление символов в любом месте текста.

3. Гибкое управление памятью:

Преимущество: Узлы списка могут быть расположены в разных участках памяти. Не требуется непрерывный блок.

Пример: Когда не хватает непрерывной памяти для массива, связный список позволяет разместить элементы в разрозненных блоках.



Недостатки связных списков:
1. Медленный доступ к произвольному элементу:

Недостаток: Для доступа к элементу по индексу необходимо последовательно перебирать элементы, начиная с начала списка (O(n) время).

Пример: Если вам нужно часто получать доступ к элементам по индексу (например, list[5]), то массив будет более эффективным.

2. Дополнительные затраты памяти:

Недостаток: Для каждого элемента (узла) необходимо хранить указатель(и) (на следующий и, возможно, предыдущий элемент). Это увеличивает потребление памяти.

Пример: Если храните небольшие целые числа, то накладные расходы на указатели могут быть существенными.

3. Кэш-недружественность:

Недостаток: Узлы списка могут быть разбросаны по памяти, что снижает эффективность использования кэша процессора (по сравнению с массивами, где элементы расположены последовательно).

Пример: При интенсивном переборе элементов списка может наблюдаться снижение производительности из-за частых промахов кэша.



Источники: 

https://habr.com/ru/articles/337558/
https://codelessons.dev/ru/spisok-list-v-s-polnyj-material/
https://habr.com/ru/sandbox/153128/
https://tproger.ru/translations/linked-list-for-beginners
https://ru.wikipedia.org/wiki/Связный_список#Линейный_связный_список
https://chatgptchatapp.com/ <3
Видева: 

https://www.youtube.com/watch?v=o5wJkJJpKtM&t=539s&ab_channel=PaulProgramming
https://www.youtube.com/watch?v=sVbvgL3geVM&ab_channel=KevinWood%7CRobotics%26AI
https://www.youtube.com/watch?v=JdQeNxWCguQ&ab_channel=mycodeschool
https://www.youtube.com/watch?v=_F-5cAg8D-w&ab_channel=CSEngineeringGyan

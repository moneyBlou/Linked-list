#include <iostream>

using namespace std;
// Структура Node представляет узел односвязного списка.
struct Node {
	int data;	// Данные, хранимые в узле (целое число в данном случае).
	Node* next;	// Указатель на следующий узел в списке. nullptr, если это последний узел.
	// Конструктор узла: инициализирует данные и указатель next.
	Node(int value) : data(value), next(nullptr) {}
};

class SingleLinkedList {
private:
	Node* head; // Указатель на первый узел списка (голова).
	Node* tail; // Указатель на последний узел списка(хвост).Добавлен для оптимизации push_back.

	int size;// Количество элементов в списке.

public:
	//Конструктор списка: создает пустой список || инициализирует переменные
	SingleLinkedList() : head(nullptr), tail(nullptr), size(0) {}

	//Деструктор: освобождает память, занятую узлами списка
	~SingleLinkedList() {
		Node* current = head;	//Начинаем с головы списка

		while (current != nullptr) {	//Пока не достигнет конца списка
			Node* next = current->next;	//Сохраняем указатель на следующий узел, чтоб не потерять связь
			delete current;	//Удаляем текущий узел
			current = next; //Переходим к следующему узлу
		}

		head = nullptr;	//После удаления всех узлов, обнуляем указатели на голову 
		tail = nullptr;	//Аналогично для хвоста
		size = 0;	//И размер списка
	}

	// Проверка, является ли список пустым (isEmpty).
	bool isEmpty() const {
		return head == nullptr;  // Возвращаем true, если head равен nullptr (список пуст), иначе false.
	}
	// Получение размера списка (getSize).
	int getSize() const {
		return size; // Возвращаем текущий размер списка.
	}

	//Метод push_front: добавляет элемент в начало списка
	void push_front(int value) {
		//1. Создаем новый узел, используем конструктор
		Node* newNode = new Node(value);
		//2. Устанавливаем указатель next нового узла на текущую голову списка
		newNode->next = head;
		//3. Обновляем указатель head, чтобы он указывал на новый узел. Новый узел становится головой списка.
		head = newNode;
		//4. Если список пуст, то новый узел так же является хвостом.
		if (tail == nullptr) {
			tail = newNode;
		}
		//5. Увеличиваем размер списка
		size++;
	}

	//Метод push_front: добавляет элемент в начало списка
	void push_back(int value) {
		//1. Создаем новый узел, используем конструктор
		Node* newNode = new Node(value);
		//2. Если список пуст:
		if (isEmpty()) {
			//Новый узел является и головой и хвостом списка
			head = newNode;
			tail = newNode;
		}
		else {
			//3. Если список не был пуст, то:
			//Устанавливаем указатель next текущего хвоста на новый узел
			tail->next = newNode;

			//Обновляем хвост списка, чтоб он указывал на новый узел
			tail = newNode;
		}
		//4. Увеличиваем размер списка
		size++;
	}

	//Метод pop_front: удаление с начала списка
	void pop_front() {
		//1. Проверяем не пуст ли список
		if (isEmpty()) {
			cout << "Ошибка! Список пуст!" << endl;
			return;
		}
		// 2. Сохраняем указатель на текущую голову списка (узел, который нужно удалить).
		Node* temp = head;

		// 3. Обновляем указатель head, чтобы он указывал на следующий узел (второй узел становится первым).
		head = head->next;

		// 4. Если после удаления голова стала nullptr (список теперь пуст), то хвост тоже должен быть nullptr.
		if (head == nullptr) {
			tail = nullptr; // Обновляем tail, если это был единственный элемент в списке.
		}

		// 5. Удаляем узел, на который указывал temp (прежнюю голову списка).
		delete temp;

		// 6. Уменьшаем размер списка.
		size--;
	}

	//Метод pop_back: удаление с конца
	void pop_back() {
		//Проверка, не пуст ли список
		if (isEmpty()) {
			cout << "Ошибка! Список пуст!" << endl;
			return;	//Если список пуст, выходим из функции
		}
		//2. Если в списке один элемент:
		if (getSize() == 1) {
			delete head; //Удаляем единственный элемент
			head = nullptr;	//Обнуляем указатель на head 
			tail = nullptr;	//Обнуляем указатель на tail
			size = 0;	//Обнуляем размер списка
			return;	//Завершаем функцию
		}
		//3. Если в списке больше 1 элемента:
		Node* current = head;	//Начинаем с головы списка
		while (current->next != tail) {	//Перебираем список, пока не дойдем до предпоследнего элемента
			current = current->next;	//Переходим к следующему узлу
		}

		//Current теперь указывает на предпоследний узел
		// Сохраняем указатель на последний элемент (хвост)
		Node* temp = tail;
		// Обновляем хвост, чтобы он указывал на предпоследний узел
		tail = current;
		//Устанавливаем next предпоследнего узла в nullptr, чтоб последний элемент был удален
		tail->next = nullptr;

		// Удаляем последний узел (temp)
		delete temp;
		// Уменьшаем размер списка.
		size--;
	}

	//Метод printList: вывод элементов списка
	void printList() {
		Node* current = head;  // Начинаем с головы списка.
		while (current != nullptr) { // Пока не достигнут конец списка.
			cout << current->data << " ";  // Выводим данные текущего узла.
			current = current->next; // Переходим к следующему узлу.
		}
		cout << endl;  // Переходим на новую строку после вывода.
	}

	//Метод find: поиск элемента по значению
	bool find(int value) const { // Константный метод, так как не изменяет список.
		// 1. Проверяем, не пуст ли список.
		if (isEmpty()) {
			cout << "Предупреждение: Список пуст. Поиск невозможен." << endl;
			return false; // Если список пуст, возвращаем false.
		}
		// 2. Начинаем обход списка с головы.
		Node* current = head;
		while (current != nullptr) {  // Пока не достигнем конца списка.
			// 3. Сравниваем данные текущего узла с искомым значением.
			if (current->data == value) {
				return true;  // Если найдено совпадение, возвращаем true.
			}
			// 4. Переходим к следующему узлу.
			current = current->next;
		}

		// 5. Если значение не найдено, возвращаем false.
		return false;
	}
};

int main() {
	SingleLinkedList myList;

	myList.pop_front();

	myList.push_front(3);  // Добавляем элемент 3 в начало списка.
	// Ожидаемый результат: head -> 3, tail -> 3, size = 1.
	myList.push_front(2);  // Добавляем элемент 2 в начало списка.
	// Ожидаемый результат: head -> 2 -> 3, tail -> 3, size = 2.
	myList.push_front(1);  // Добавляем элемент 1 в начало списка.
	// Ожидаемый результат: head -> 1 -> 2 -> 3, tail -> 3, size = 3.
	myList.push_back(4);   // Добавляем элемент 4 в конец списка.
	// Ожидаемый результат: head -> 1 -> 2 -> 3 -> 4, tail -> 4, size = 4.
	myList.push_back(5);   // Добавляем элемент 5 в конец списка.
	// Ожидаемый результат: head -> 1 -> 2 -> 3 -> 4 -> 5, tail -> 5, size = 5

	cout << "Список: ";  // Вывод строки "Список: " в консоль.
	myList.printList();  // Вывод элементов списка в консоль.
	// Ожидаемый результат: Вывод "1 2 3 4 5" в консоль.

	cout << "Размер: " << myList.getSize() << endl;  // Вывод размера списка в консоль.
	// Ожидаемый результат: Вывод "Размер: 5" в консоль.

	cout << "Пустой: " << myList.isEmpty() << endl;  // Проверка, пуст ли список, и вывод результата в консоль.
	// Ожидаемый результат: Вывод "Пустой: 0" (или "Пустой: false" в зависимости от реализации ostream для bool) в консоль.

	myList.pop_back();  // Удаляем последний элемент (5) из списка.
	// Ожидаемый результат: head -> 1 -> 2 -> 3 -> 4, tail -> 4, size = 4.
	cout << "Список после pop_back: ";  // Вывод строки "Список после pop_back: " в консоль.
	myList.printList();  // Вывод элементов списка в консоль после удаления.
	// Ожидаемый результат: Вывод "1 2 3 4" в консоль.

	myList.pop_front();  // Удаляем первый элемент (1) из списка.
	// Ожидаемый результат: head -> 2 -> 3 -> 4, tail -> 4, size = 3.
	cout << "Список после pop_front: ";  // Вывод строки "Список после pop_front: " в консоль.
	myList.printList();  // Вывод элементов списка в консоль после удаления.
	// Ожидаемый результат: Вывод "2 3 4" в консоль.

	cout << "Размер: " << myList.getSize() << endl;  // Вывод размера списка в консоль.
	// Ожидаемый результат: Вывод "Размер: 3" в консоль.

	return 0;
}